searchState.loadedDescShard("hotshot_state_prover", 0, "SNARK-assisted <code>HotShot</code> light client state update …\nState verifier circuit builder Circuit implementation for …\nUtilities for test\nProver service related functionalities A light client …\nSNARK proof generation\nLight client state Variable\nLight client state Variable The stake table commitment is …\nVariable for stake table entry\nReturns the Merkle root of the block commitments\nReturns the block height\nA function that takes as input:\nInternal function to build a dummy circuit\nReturns the commitment of the fee ledger\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nErrors\nCommitment for QC verification keys\nStake amount\nCommitment for stake amount\nReturns the commitment of the associated stake table\nCommitment for state verification keys\nstate verification keys\nLossy conversion of a U256 into a field element.\nPrivate list holding all variables <code>vars[0]</code>: view number …\nReturns the view number\nNumber of blocks per epoch for testing\nMock of hotshot ledger for testing LightClient.sol …\nMock for system parameter of <code>MockLedger</code>\nStake table capacity used for testing\nnumber of blocks per epoch\nElapse an epoch with <code>num_reg</code> of new registration, <code>num_exit</code> …\nElapse a view with a new finalized block\nElapse a view without a new finalized block (e.g. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nreturn list of (proof, ver_key, public_input, extra_msg, …\nReturn the light client state and proof of consensus on …\na malicious attack, generating a fake stake table full of …\nReturns the (bytes32 votingStakeTableComm, bytes32 …\nReturns the <code>LightClientState</code> for solidity\nInit the system parameters (some fixed, some adjustable)\nInitialize the ledger with genesis state\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper function for test\nmax capacity of stake table\nHelper function for test\nUpdate stake table with <code>num_reg</code> number of new …\nError when communicating with the smart contract: {0}\nInternal error\nInvalid light client state or signatures\nInternal error when generating the SNARK proof\nError when communicating with the state relay server: {0}\nA wallet with local signer and connected to network via …\nInternal error with the stake table\nConfiguration/Parameters used for hotshot state prover\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize the stake table from a sequencer node that is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAddress of LightClient contract\nA helper function to compute the quorum threshold given a …\nIf daemon and provided, the service will run a basic HTTP …\nprepare a contract interface ready to be read from or …\nURL of the chain (layer 1  or any layer 2) JSON-RPC …\nget the <code>finalizedState</code> from the LightClient contract …\nUrl of the state relay server (a CDN that sequencers push …\nInterval between retries if a state update fails\nRun light client state prover once\nURL of a node that is currently providing the HotShot …\nTransaction signing key for Ethereum or any other layer 2\nStake table capacity for the prover circuit.\nsubmit the latest finalized state along with a proof to …\nInterval between light client state update\nProof\nProving key\nBLS verification key, base field and Schnorr verification …\nUniversal SRS\nVerifying key\n\\beta times the above generator of G2.\nDeserialize <code>Self</code> using <code>ark-serialize</code> (uncompressed)\nThe size of the evaluation domain. Should be a power of …\nReturns the argument unchanged.\nGiven a proving key and\nTODO: remove h and beta_h The generator of G2.\nGet the internal of verifying key, namely a curve Point\nCalls <code>U::from(self)</code>.\nA flag indicating whether the key is a merged key.\nThe constants K0, …, K_num_wire_types that ensure wire …\nThe number of public inputs.\nKZG PCS opening key.\n(Aggregated) proof of evaluations at challenge point <code>zeta</code>.\nThe partial proof for Plookup argument\nPlookup verifying key, None if not support lookup.\nPolynomial evaluations.\nGroup elements of the form <code>{ \\beta^i G }</code>, where <code>i</code> ranges …\npowers of \\beta time the generator h of G2\nGiven a SRS, returns the proving key and verifying key for …\nThe polynomial commitment for the wire permutation …\nThe selector polynomial commitments. The commitments are …\nSerialize <code>Self</code> using <code>ark-serialize</code> (uncompressed)\n(Aggregated) proof of evaluation at challenge point …\nThe permutation polynomial commitments. The commitments …\nSplit quotient polynomial commitments.\nConvert the verification key into the affine form.\nSignature verification function\nThe verifying key. It is used by prover to initialize …\nWire witness polynomials commitments.")