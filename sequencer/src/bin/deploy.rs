use anyhow::Context;
use async_compatibility_layer::logging::{setup_backtrace, setup_logging};
use async_std::sync::Arc;
use clap::Parser;
use contract_bindings::{
    erc1967_proxy::ERC1967Proxy, hot_shot::HotShot, light_client::LightClient,
};
use ethers::prelude::{coins_bip39::English, *};
use futures::future::FutureExt;
use hotshot_stake_table::config::STAKE_TABLE_CAPACITY;
use hotshot_state_prover::service::light_client_genesis;
use sequencer::deployer::{
    deploy_light_client_contract, deploy_mock_light_client_contract, Contract, Contracts,
    DeployedContracts,
};
use std::{fs::File, io::stdout, path::PathBuf};
use url::Url;

/// Deploy contracts needed to run the sequencer.
///
/// This script deploys contracts needed to run the sequencer to an L1. It outputs a .env file
/// containing the addresses of the deployed contracts.
///
/// This script can also be used to do incremental deployments. The only contract addresses needed
/// to configure the sequencer network are ESPRESSO_SEQUENCER_HOTSHOT_ADDRESS and
/// ESPRESSO_SEQUENCER_LIGHT_CLIENT_PROXY_ADDRESS. These contracts, however, have dependencies, and
/// a full deployment may involve up to 5 total contracts. Some of these contracts, especially
/// libraries may already have been deployed, or perhaps one of the top-level contracts has been
/// deployed and we only need to deploy the other one.
///
/// It is possible to pass in the addresses of already deployed contracts, in which case those
/// addresses will be used in place of deploying a new contract wherever that contract is required
/// in the deployment process. The generated .env file will include all the addresses passed in as
/// well as those newly deployed.
#[derive(Clone, Debug, Parser)]
struct Options {
    /// A JSON-RPC endpoint for the L1 to deploy to.
    #[clap(
        short,
        long,
        env = "ESPRESSO_SEQUENCER_L1_PROVIDER",
        default_value = "http://localhost:8545"
    )]
    rpc_url: Url,

    /// URL of the HotShot orchestrator.
    ///
    /// This is used to get the stake table for initializing the light client contract.
    #[clap(
        long,
        env = "ESPRESSO_SEQUENCER_ORCHESTRATOR_URL",
        default_value = "http://localhost:40001"
    )]
    orchestrator_url: Url,

    /// Mnemonic for an L1 wallet.
    ///
    /// This wallet is used to deploy the contracts, so the account indicated by ACCOUNT_INDEX must
    /// be funded with with ETH.
    #[clap(
        long,
        name = "MNEMONIC",
        env = "ESPRESSO_SEQUENCER_ETH_MNEMONIC",
        default_value = "test test test test test test test test test test test junk"
    )]
    mnemonic: String,
    /// Account index in the L1 wallet generated by MNEMONIC to use when deploying the contracts.
    #[clap(
        long,
        name = "ACCOUNT_INDEX",
        env = "ESPRESSO_DEPLOYER_ACCOUNT_INDEX",
        default_value = "0"
    )]
    account_index: u32,

    /// Write deployment results to OUT as a .env file.
    ///
    /// If not provided, the results will be written to stdout.
    #[clap(short, long, name = "OUT", env = "ESPRESSO_DEPLOYER_OUT_PATH")]
    out: Option<PathBuf>,

    #[clap(flatten)]
    contracts: DeployedContracts,

    /// If toggled, launch a mock prover contract that does not do any proof verification.
    #[clap(short, long)]
    pub use_mock_contract: bool,

    /// Stake table capacity for the prover circuit
    #[clap(short, long, env = "ESPRESSO_SEQUENCER_STAKE_TABLE_CAPACITY", default_value_t = STAKE_TABLE_CAPACITY)]
    pub stake_table_capacity: usize,
}

#[async_std::main]
async fn main() -> anyhow::Result<()> {
    setup_logging();
    setup_backtrace();

    let opt = Options::parse();
    let mut contracts = Contracts::from(opt.contracts);

    let provider = Provider::<Http>::try_from(opt.rpc_url.to_string())?;
    let chain_id = provider.get_chainid().await?.as_u64();
    let wallet = MnemonicBuilder::<English>::default()
        .phrase(opt.mnemonic.as_str())
        .index(opt.account_index)?
        .build()?
        .with_chain_id(chain_id);
    let owner = wallet.address();
    let l1 = Arc::new(SignerMiddleware::new(provider, wallet));

    contracts
        .deploy_tx(Contract::HotShot, HotShot::deploy(l1.clone(), ())?)
        .await?;

    if opt.use_mock_contract {
        // LightClientMock is a non-upgradable contract, thus directly initialize
        // it via its constructor
        contracts
            .deploy_fn(Contract::LightClient, |contracts| {
                deploy_mock_light_client_contract(l1.clone(), contracts, None).boxed()
            })
            .await?;
    } else {
        // LightClient is a upgradable contract, thus deploy first,
        // then initialize it through a proxy contract
        let lc_address = contracts
            .deploy_fn(Contract::LightClient, |contracts| {
                deploy_light_client_contract(l1.clone(), contracts).boxed()
            })
            .await?;
        let light_client = LightClient::new(lc_address, l1.clone());

        let genesis = light_client_genesis(&opt.orchestrator_url, opt.stake_table_capacity).await?;
        let data = light_client
            .initialize(genesis.into(), u32::MAX, owner)
            .calldata()
            .context("calldata for initialize transaction not available")?;
        contracts
            .deploy_tx(
                Contract::LightClientProxy,
                ERC1967Proxy::deploy(l1.clone(), (lc_address, data))?,
            )
            .await?;
    }

    if let Some(out) = &opt.out {
        let file = File::options().create(true).write(true).open(out)?;
        contracts.write(file)?;
    } else {
        contracts.write(stdout())?;
    }

    Ok(())
}
