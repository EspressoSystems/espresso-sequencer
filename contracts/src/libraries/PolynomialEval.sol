// SPDX-License-Identifier: Unlicensed

pragma solidity ^0.8.0;

import { BN254 } from "bn254/BN254.sol";

/* solhint-disable no-inline-assembly */

library PolynomialEval {
    /// Unsupported polynomial degree, currently size must in 2^{14~17}.
    error UnsupportedDegree();

    /// @dev a Radix 2 Evaluation Domain
    struct EvalDomain {
        uint256 logSize; // log_2(self.size)
        uint256 sizeInv; // Inverse of the size in the field
        uint256[11] elements; // 1, g, g^2, ..., g^10
    }

    /// @dev stores vanishing poly, lagrange at 1, and Public input poly
    struct EvalData {
        BN254.ScalarField vanishEval;
        BN254.ScalarField lagrangeOne;
        BN254.ScalarField piEval;
    }

    /// @dev Create a new Radix2EvalDomain with `domainSize` which should be power of 2.
    /// @dev Will revert if domainSize is not among {2^5, 2^16, 2^20}
    /// @dev The hardcoded values are generated by the rust script `eval-domain`.
    function newEvalDomain(uint256 domainSize) internal pure returns (EvalDomain memory) {
        if (domainSize == 65536) {
            // For testing purposes
            return EvalDomain(
                16,
                0x30641e0e92bebef818268d663bcad6dbcfd6c0149170f6d7d350b1b1fa6c1001,
                [
                    0x1,
                    0xeeb2cb5981ed45649abebde081dcff16c8601de4347e7dd1628ba2daac43b7,
                    0x2d1ba66f5941dc91017171fa69ec2bd0022a2a2d4115a009a93458fd4e26ecfb,
                    0x86812a00ac43ea801669c640171203c41a496671bfbc065ac8db24d52cf31e5,
                    0x2d965651cdd9e4811f4e51b80ddca8a8b4a93ee17420aae6adaa01c2617c6e85,
                    0x12597a56c2e438620b9041b98992ae0d4e705b780057bf7766a2767cece16e1d,
                    0x2d94117cd17bcf1290fd67c01155dd40807857dff4a5a0b4dc67befa8aa34fd,
                    0x15ee2475bee517c4ee05e51fa1ee7312a8373a0b13db8c51baf04cb2e99bd2bd,
                    0x6fab49b869ae62001deac878b2667bd31bf3e28e3a2d764aa49b8d9bbdd310,
                    0x2e856bf6d037708ffa4c06d4d8820f45ccadce9c5a6d178cbd573f82e0f97011,
                    0x1407eee35993f2b1ad5ec6d9b8950ca3af33135d06037f871c5e33bf566dd7b4
                ]
            );
        } else if (domainSize == 1048576) {
            return EvalDomain(
                20,
                0x30644b6c9c4a72169e4daa317d25f04512ae15c53b34e8f5acd8e155d0a6c101,
                [
                    0x1,
                    0x26125da10a0ed06327508aba06d1e303ac616632dbed349f53422da953337857,
                    0x2260e724844bca5251829353968e4915305258418357473a5c1d597f613f6cbd,
                    0x2087ea2cd664278608fb0ebdb820907f598502c81b6690c185e2bf15cb935f42,
                    0x19ddbcaf3a8d46c15c0176fbb5b95e4dc57088ff13f4d1bd84c6bfa57dcdc0e0,
                    0x5a2c85cfc591789605cae818e37dd4161eef9aa666bec6fe4288d09e6d23418,
                    0x11f70e5363258ff4f0d716a653e1dc41f1c64484d7f4b6e219d6377614a3905c,
                    0x29e84143f5870d4776a92df8da8c6c9303d59088f37ba85f40cf6fd14265b4bc,
                    0x1bf82deba7d74902c3708cc6e70e61f30512eca95655210e276e5858ce8f58e5,
                    0x22b94b2e2b0043d04e662d5ec018ea1c8a99a23a62c9eb46f0318f6a194985f0,
                    0x29969d8d5363bef1101a68e446a14e1da7ba9294e142a146a980fddb4d4d41a5
                ]
            );
        }
        if (domainSize == 32) {
            // useful for small-size test, in practice unlikely to be used.
            return EvalDomain(
                5,
                0x2ee12bff4a2813286a8dc388cd754d9a3ef2490635eba50cb9c2e5e750800001,
                [
                    0x1,
                    0x9c532c6306b93d29678200d47c0b2a99c18d51b838eeb1d3eed4c533bb512d0,
                    0x21082ca216cbbf4e1c6e4f4594dd508c996dfbe1174efb98b11509c6e306460b,
                    0x1277ae6415f0ef18f2ba5fb162c39eb7311f386e2d26d64401f4a25da77c253b,
                    0x2b337de1c8c14f22ec9b9e2f96afef3652627366f8170a0a948dad4ac1bd5e80,
                    0x2fbd4dd2976be55d1a163aa9820fb88dfac5ddce77e1872e90632027327a5ebe,
                    0x107aab49e65a67f9da9cd2abf78be38bd9dc1d5db39f81de36bcfa5b4b039043,
                    0xe14b6364a47e9c4284a9f80a5fc41cd212b0d4dbf8a5703770a40a9a343990,
                    0x30644e72e131a029048b6e193fd841045cea24f6fd736bec231204708f703636,
                    0x22399c34139bffada8de046aac50c9628e3517a3a452795364e777cd65bb9f48,
                    0x2290ee31c482cf92b79b1944db1c0147635e9004db8c3b9d13644bef31ec3bd3
                ]
            );
        } else {
            revert UnsupportedDegree();
        }
    }

    // This evaluates the vanishing polynomial for this domain at zeta.
    // For multiplicative subgroups, this polynomial is
    // `z(X) = X^self.size - 1`.
    function evaluateVanishingPoly(EvalDomain memory self, uint256 zeta)
        internal
        pure
        returns (uint256 res)
    {
        uint256 p = BN254.R_MOD;
        uint256 logSize = self.logSize;

        assembly {
            switch zeta
            case 0 { res := sub(p, 1) }
            default {
                res := zeta
                for { let i := 0 } lt(i, logSize) { i := add(i, 1) } { res := mulmod(res, res, p) }
                // since zeta != 0 we know that res is not 0
                // so we can safely do a subtraction
                res := sub(res, 1)
            }
        }
    }

    /// @dev Evaluate the lagrange polynomial at point `zeta` given the vanishing polynomial
    /// evaluation `vanish_eval`.
    function evaluateLagrangeOne(
        EvalDomain memory self,
        BN254.ScalarField zeta,
        BN254.ScalarField vanishEval
    ) internal view returns (BN254.ScalarField res) {
        if (BN254.ScalarField.unwrap(zeta) == 1) {
            // when zeta is first element in the eval domain
            return BN254.ScalarField.wrap(1);
        }
        if (BN254.ScalarField.unwrap(vanishEval) == 0) {
            // else, if zeta is other elements in the eval domain
            return BN254.ScalarField.wrap(0);
        }

        uint256 p = BN254.R_MOD;
        uint256 divisor;
        uint256 vanishEvalMulSizeInv = self.sizeInv;

        // =========================
        // lagrange_1_eval = vanish_eval / self.size / (zeta - 1)
        // =========================
        assembly {
            vanishEvalMulSizeInv := mulmod(vanishEval, vanishEvalMulSizeInv, p)

            switch zeta
            case 0 { divisor := sub(p, 1) }
            default { divisor := sub(zeta, 1) }
        }
        divisor = BN254.ScalarField.unwrap((BN254.invert(BN254.ScalarField.wrap(divisor))));
        assembly {
            res := mulmod(vanishEvalMulSizeInv, divisor, p)
        }
    }

    /// @dev Evaluate public input polynomial at point `zeta`.
    function evaluatePiPoly(
        EvalDomain memory self,
        uint256[11] memory pi,
        uint256 zeta,
        uint256 vanishingPolyEval
    ) internal view returns (uint256 res) {
        uint256 p = BN254.R_MOD;

        if (vanishingPolyEval == 0) {
            uint256 group = 1;
            for (uint256 i = 0; i < 11; i++) {
                if (zeta == group) {
                    return pi[i];
                }
                group = mulmod(group, self.elements[1], p);
            }
            return 0;
        }

        // In order to compute PiPoly(zeta) in an efficient way, we can do the following derivation:

        // PiPoly(zeta) = \sum_{i=0}^{length} pi[i] * L_i(zeta) where
        // L_i(zeta) = (Z_H(zeta) * g^i) / (n * (zeta - g^i))
        // PiPoly(zeta) = (Z_H(zeta) / n) * \sum_{i=0}^{length} pi[i] * g^i * (\prod_{i neq j}
        // (zeta - g^j)) / (\prod_{j=0}^{length} (zeta - g^j))

        // Since the denominator (\prod_{j=0}^{length} (zeta - g^j)) is the total product and
        // doesn't depend on i, we can take it out of the sum and compute it once.

        // PiPoly(zeta) = vanishingPolyEval / (n * fullProduct) * \sum_{i=0}^{length} pi[i] * g^i *
        // (\prod_{i != j} (zeta - g^j))

        // where fullProduct = \prod_{j=0}^{length} (zeta - g^j)

        // Another optimization we can do is instead of computing the product where i != j, we can
        // precompute the prefix and suffix products and just calculate prefix[i] * suffix[i] to get
        // the product (\prod_{i != j} (zeta - g^j)).
        // The prefix array doesn't need to be kept in memory, it can be computed on the fly when
        // computing the sum.
        // We keep currentElementPrefix = \prod_{j=0}^{i} (zeta - g^j) and update it at each i.

        // compute suffix product array as described in the function _computeSuffixProduct
        // this helps optimize the PiPoly computation by using the following formula:
        // PiPoly(zeta) = vanishingPolyEval / (n * fullProduct) * \sum_{i=0}^{length}
        // (currentElementPrefix * suffix[i] * pi[i] * g^i)

        // Compute suffix product
        // This optimization keeps the 1 inversion but reduces the number of multiplications from
        // n(n - 1) to 3n
        //
        // credit: @shresthagrawal and @jakovmitrovski from CommonPrefix
        uint256[11] memory suffix;

        // Assume we have [a, b, c, d] where a = zeta - g^0, b = zeta - g^1, ...
        //
        // suffix[length - i - 1] = suffix[length - i] * (zeta - g^(length - i)) and
        // suffix[length - 1] = 1
        // suffix = [dcb, dc, d, 1]
        assembly {
            let suffixPtr := add(suffix, mul(10, 0x20))
            let localDomainElementsPtr := add(mload(add(self, 0x40)), mul(10, 0x20))
            let currentElementSuffix := 1

            // Last element of suffix is set to 1
            mstore(suffixPtr, currentElementSuffix)

            // Calculate prefix and suffix products
            for { let i := 1 } lt(i, 11) { i := add(i, 1) } {
                // move suffix pointer
                suffixPtr := sub(suffixPtr, 0x20)

                // suffix[length - i - 1] = suffix[length - i] * (zeta - g^(length - i))
                currentElementSuffix :=
                    mulmod(
                        currentElementSuffix, addmod(sub(p, mload(localDomainElementsPtr)), zeta, p), p
                    )
                mstore(suffixPtr, currentElementSuffix)

                localDomainElementsPtr := sub(localDomainElementsPtr, 0x20)
            }
        }

        uint256 fullProduct;
        uint256 sum = 0;

        assembly {
            let currentElementPrefix := 1
            let suffixPtr := suffix
            let piPtr := pi
            let localDomainElementsPtr := mload(add(self, 0x40))

            // Compute the sum term \sum_{i=0}^{length} currentElementPrefix * suffix[i] * pi[i] *
            // g^i
            for { let i := 0 } lt(i, 11) { i := add(i, 1) } {
                // sum += currentElementPrefix * suffix[i] * pi[i] * g^i
                let currentTerm :=
                    mulmod(
                        mulmod(mulmod(currentElementPrefix, mload(suffixPtr), p), mload(piPtr), p),
                        mload(localDomainElementsPtr),
                        p
                    )
                sum := addmod(sum, currentTerm, p)

                // currentElementPrefix holds \prod_{j=0}^{i} (zeta - g^j) and is updated at each i.
                currentElementPrefix :=
                    mulmod(
                        currentElementPrefix, addmod(sub(p, mload(localDomainElementsPtr)), zeta, p), p
                    )

                // move the pointers
                suffixPtr := add(suffixPtr, 0x20)
                piPtr := add(piPtr, 0x20)
                localDomainElementsPtr := add(localDomainElementsPtr, 0x20)
            }

            fullProduct := currentElementPrefix
        }

        // 1 / fullProduct
        uint256 invertedProduct =
            BN254.ScalarField.unwrap(BN254.invert(BN254.ScalarField.wrap(fullProduct)));

        assembly {
            // Final computation
            let nInverted := mload(add(self, 0x20)) // 1/n
            // (vanishingPolyEval / ( n * fullProduct )) * sum
            res := mulmod(vanishingPolyEval, nInverted, p)
            res := mulmod(res, invertedProduct, p)
            res := mulmod(res, sum, p)
        }
    }

    /// @dev compute the EvalData for a given domain and a challenge zeta
    function evalDataGen(EvalDomain memory self, uint256 zeta, uint256[11] memory publicInput)
        internal
        view
        returns (EvalData memory evalData)
    {
        evalData.vanishEval = BN254.ScalarField.wrap(evaluateVanishingPoly(self, zeta));
        evalData.lagrangeOne =
            evaluateLagrangeOne(self, BN254.ScalarField.wrap(zeta), evalData.vanishEval);
        evalData.piEval = BN254.ScalarField.wrap(
            evaluatePiPoly(self, publicInput, zeta, BN254.ScalarField.unwrap(evalData.vanishEval))
        );
    }
}
