<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Multi-producer, multi-consumer oneshot notification channel"><title>hotshot_query_service::data_source::notifier - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="hotshot_query_service" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../hotshot_query_service/index.html">hotshot_<wbr>query_<wbr>service</a><span class="version">0.1.76</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module notifier</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#dropped-receivers-do-not-consume-resources" title="Dropped receivers do not consume resources">Dropped receivers do not consume resources</a></li><li><a href="#messages-are-not-copied-for-receivers-who-dont-want-them" title="Messages are not copied for receivers who donâ€™t want them.">Messages are not copied for receivers who donâ€™t want them.</a></li><li><a href="#minimal-resource-contention-for-concurrent-subscriptions" title="Minimal resource contention for concurrent subscriptions.">Minimal resource contention for concurrent subscriptions.</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In hotshot_<wbr>query_<wbr>service::<wbr>data_<wbr>source</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">hotshot_query_service</a>::<wbr><a href="../index.html">data_source</a></span><h1>Module <span>notifier</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/hotshot_query_service/data_source/notifier.rs.html#13-387">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Multi-producer, multi-consumer oneshot notification channel</p>
<p><a href="struct.Notifier.html" title="struct hotshot_query_service::data_source::notifier::Notifier"><code>Notifier</code></a> is an asynchronous, multi-producer, multi-consumer, oneshot channel satisfying
three additional requirements:</p>
<ol>
<li>Dropped receivers do not consume resources.</li>
<li>Messages are not copied for receivers who donâ€™t want them.</li>
<li>Minimal resource contention for concurrent subscriptions.</li>
</ol>
<h3 id="dropped-receivers-do-not-consume-resources"><a class="doc-anchor" href="#dropped-receivers-do-not-consume-resources">Â§</a>Dropped receivers do not consume resources</h3>
<p>This requirement is a direct prerequisite of the broader requirement that passive requests for
resources do not consume resources. This is important because in general, passive requests may
be for resources that are not guaranteed to exist, and thus may never terminate. Just like we
avoid spawning a task for passive requests, since it may never complete, we need receivers for
passive requests not to persist beyond the lifetime of the request, or they may never be closed.</p>
<p>This requirement is implemented via garbage collection: each time a message is sent, resources
belonging to dropped receivers are cleaned up. Thus, strictly speaking, dropped receivers do
consume resources, but only briefly. There is no need to keep them around until the desired
message is delivered, for example.</p>
<h3 id="messages-are-not-copied-for-receivers-who-dont-want-them"><a class="doc-anchor" href="#messages-are-not-copied-for-receivers-who-dont-want-them">Â§</a>Messages are not copied for receivers who donâ€™t want them.</h3>
<p>The second requirement simplifies the higher level fetching logic by allowing us to maintain a
single channel for all notifications about a particular resource type, rather than separate
channels for each specific request. Since messages are not copied for all subscribers, but only
for the subscribers interested in a particular message, this simplification becomes nearly
cost-free.</p>
<p>This requirement is implemented by attaching a predicate to each subscription, which takes a
message by reference. The predicate is checked on the sending side, and the message is only
copied to the subscription if the predicate is satisfied.</p>
<h3 id="minimal-resource-contention-for-concurrent-subscriptions"><a class="doc-anchor" href="#minimal-resource-contention-for-concurrent-subscriptions">Â§</a>Minimal resource contention for concurrent subscriptions.</h3>
<p>This is important because subscriptions are requested in response to read-only client requests,
which are supposed to run in parallel as much as possible. By contrast, notifications are
usually send from internal server tasks (e.g. the background task that updates the data source
when new blocks are committed). It is less of a problem if these internal tasks contend with
each other, because they are not directly blocking responses to clients, and we have more
control over how and when they acquire shared resources.</p>
<p>This requirement also empowers us to create a simpler design for the high-level fetching logic.
Specifically, we can reuse the same code for fetching individual resources as we use for
long-lived subscription streams (e.g. <code>subscribe_blocks</code> is a thin wrapper around
<code>get_block_range</code>). We do not have to worry about adding complex logic to reuse notification
subscriptions for long-lived streams, because subscribing anew for each entry in the stream has
low overhead in terms of contention over shared resources â€“ the dominant caused in any
concurrent channel, after data copying (see above).</p>
<p>This further lets us simplify the interface of this channel a bit: since all notifications are
oneshot, consumers deal with futures rather than streams.</p>
<p>This requirement is satisfied by maintaining the list of subscribers to a <a href="struct.Notifier.html" title="struct hotshot_query_service::data_source::notifier::Notifier"><code>Notifier</code></a> in a way
that moves most resource contention to message senders, rather than receivers. We make the
assumption that there is less concurrency among senders. In the common case, there is just one
sender: the task monitoring HotShot for new blocks. Occasionally, there may be other tasks
spawned to fetch missing resources and send them through the <a href="struct.Notifier.html" title="struct hotshot_query_service::data_source::notifier::Notifier"><code>Notifier</code></a>, but these should be
relatively few and rare.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Notifier.html" title="struct hotshot_query_service::data_source::notifier::Notifier">Notifier</a></div><div class="desc docblock-short">Multi-producer, multi-consumer oneshot notification channel</div></li><li><div class="item-name"><a class="struct" href="struct.ReceiveHandle.html" title="struct hotshot_query_service::data_source::notifier::ReceiveHandle">Receive<wbr>Handle</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">A handle that closes a subscriber when dropped.</div></li><li><div class="item-name"><a class="struct" href="struct.Subscriber.html" title="struct hotshot_query_service::data_source::notifier::Subscriber">Subscriber</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="struct" href="struct.WaitFor.html" title="struct hotshot_query_service::data_source::notifier::WaitFor">WaitFor</a></div><div class="desc docblock-short">A pending request for notification.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Predicate.html" title="trait hotshot_query_service::data_source::notifier::Predicate">Predicate</a></div><div class="desc docblock-short">A predicate on a type <code>&lt;T&gt;</code>.</div></li></ul></section></div></main></body></html>