<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A data source for the APIs provided in this crate, backed by a remote PostgreSQL database."><title>SqlDataSource in hotshot_query_service::data_source::sql - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="hotshot_query_service" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../hotshot_query_service/index.html">hotshot_<wbr>query_<wbr>service</a><span class="version">0.1.76</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">SqlData<wbr>Source</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#administration" title="Administration">Administration</a><ul><li><a href="#schema" title="Schema">Schema</a></li><li><a href="#initialization" title="Initialization">Initialization</a></li><li><a href="#resetting" title="Resetting">Resetting</a></li><li><a href="#migrations" title="Migrations">Migrations</a></li><li><a href="#custom-migrations" title="Custom Migrations">Custom Migrations</a></li></ul></li><li><a href="#synchronization" title="Synchronization">Synchronization</a></li><li><a href="#extension-and-composition" title="Extension and Composition">Extension and Composition</a><ul><li><a href="#extension" title="Extension">Extension</a></li><li><a href="#composition" title="Composition">Composition</a></li></ul></li></ul><h3><a href="#aliased-type">Aliased type</a></h3><h3><a href="#fields">Fields</a></h3><ul class="block field"><li><a href="#structfield.aggregator" title="aggregator">aggregator</a></li><li><a href="#structfield.fetcher" title="fetcher">fetcher</a></li><li><a href="#structfield.pruner" title="pruner">pruner</a></li><li><a href="#structfield.scanner" title="scanner">scanner</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.connect" title="connect">connect</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-DataSourceLifeCycle-for-FetchingDataSource%3CMockTypes,+SqlStorage,+P%3E" title="DataSourceLifeCycle">DataSourceLifeCycle</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In hotshot_<wbr>query_<wbr>service::<wbr>data_<wbr>source::<wbr>sql</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">hotshot_query_service</a>::<wbr><a href="../index.html">data_source</a>::<wbr><a href="index.html">sql</a></span><h1>Type Alias <span class="type">SqlDataSource</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/hotshot_query_service/data_source/sql.rs.html#299">Source</a> </span></div><pre class="rust item-decl"><code>pub type SqlDataSource&lt;Types, P&gt; = <a class="struct" href="../fetching/struct.FetchingDataSource.html" title="struct hotshot_query_service::data_source::fetching::FetchingDataSource">FetchingDataSource</a>&lt;Types, <a class="struct" href="../storage/sql/struct.SqlStorage.html" title="struct hotshot_query_service::data_source::storage::sql::SqlStorage">SqlStorage</a>, P&gt;;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A data source for the APIs provided in this crate, backed by a remote PostgreSQL database.</p>
<h2 id="administration"><a class="doc-anchor" href="#administration">§</a>Administration</h2>
<p>This data source will automatically connect to and perform queries on a remote SQL database.
However, <em>administration</em> of the database, such as initialization, resetting, and backups, is
left out of the scope of this implementation, and is expected to be performed manually using
off-the-shelf DBMS administration tools. The one exception is migrations, which are handled
transparently by the <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a>.</p>
<h3 id="schema"><a class="doc-anchor" href="#schema">§</a>Schema</h3>
<p>All the objects created and used by <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> are grouped under a schema for easy
management. By default, the schema is named <code>hotshot</code>, and is created the first time a
<a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> is constructed. The name of the schema can be configured by setting
<a href="../storage/sql/struct.Config.html#method.schema" title="method hotshot_query_service::data_source::storage::sql::Config::schema"><code>Config::schema</code></a>.</p>
<h3 id="initialization"><a class="doc-anchor" href="#initialization">§</a>Initialization</h3>
<p>When creating a PostgreSQL <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a>, the caller can use <a href="type.Config.html" title="type hotshot_query_service::data_source::sql::Config"><code>Config</code></a> to specify the host, user, and
database for the connection. If the <code>embedded-db</code> feature is enabled, the caller can instead specify the
file path for an SQLite database.
As such, <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> is not very opinionated about how the
database instance is set up. The administrator must simply ensure that there is a database
dedicated to the <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> and a user with appropriate permissions (all on <code>SCHEMA</code> and
all on <code>DATABASE</code>) over that database.</p>
<p>Here is an example of how a sufficient database could be initialized. When using the standard
<code>postgres</code> Docker image, these statements could be placed in
<code>/docker-entrypoint-initdb.d/init.sql</code> to automatically initialize the database upon startup.</p>
<div class="example-wrap"><pre class="language-sql"><code>CREATE DATABASE hotshot_query_service;
\connect hotshot_query_service;
CREATE USER hotshot_user WITH PASSWORD &#39;password&#39;;
GRANT ALL ON SCHEMA public TO hotshot_user;
GRANT ALL ON DATABASE hotshot_query_service TO hotshot_user WITH GRANT OPTION;</code></pre></div>
<p>For SQLite, simply provide the file path, and the file will be created if it does not already exist.</p>
<p>One could then connect to this database with the following <a href="type.Config.html" title="type hotshot_query_service::data_source::sql::Config"><code>Config</code></a> for postgres:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(not(feature= <span class="string">"embedded-db"</span>))]
</span>Config::default()
    .host(<span class="string">"postgres.database.hostname"</span>)
    .database(<span class="string">"hotshot_query_service"</span>)
    .user(<span class="string">"hotshot_user"</span>)
    .password(<span class="string">"password"</span>)</code></pre></div>
<p>Or, if the <code>embedded-db</code> feature is enabled, configure it as follows for SQLite:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(feature= <span class="string">"embedded-db"</span>)]
</span>Config::default()
    .db_path(<span class="string">"temp.db"</span>.into())</code></pre></div>
<h3 id="resetting"><a class="doc-anchor" href="#resetting">§</a>Resetting</h3>
<p>In general, resetting the database when necessary is left up to the administrator. However, for
convenience, we do provide a <a href="../storage/sql/struct.Config.html#method.reset_schema" title="method hotshot_query_service::data_source::storage::sql::Config::reset_schema"><code>reset_schema</code></a> option which can be used to
wipe out existing state and create a fresh instance of the query service. This is particularly
useful for development and staging environments. This function will permanently delete all
tables associated with the schema used by this query service, but will not reset other schemas
or database.</p>
<h3 id="migrations"><a class="doc-anchor" href="#migrations">§</a>Migrations</h3>
<p>For the <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> to work, the database must be initialized with the appropriate schema,
and the schema must be kept up to date when deploying a new version of this software which
depends on a different schema. Both of these tasks are accomplished via <em>migrations</em>.</p>
<p>Each release of this software is bundled with a sequence of migration files: one migration for
each release that changed the schema, including the latest one. Replaying these SQL files
against a database with an older version of the schema, including a completely empty database,
will bring it up to date with the schema required by this version of the software. Upon creating
an instance of <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> and connecting to a database, the data source will
automatically fetch the current version from the database and, if it is old, replay the
necessary migration files.</p>
<h3 id="custom-migrations"><a class="doc-anchor" href="#custom-migrations">§</a>Custom Migrations</h3>
<p>In keeping with the philosophy of this crate, <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> is designed to be
<a href="#extension-and-composition">extensible and composable</a>. When extending the provided APIs with
new, application-specific queries, it will often be desirable to alter the schema of the
database in some way, such as adding additional columns to some of the tables or creating new
indices. When composing the provided APIs with additional API modules, it may also be desirable
to alter the schema, although the changes are more likely to be completely independent of the
schema used by this data source, such as adding entirely new tables.</p>
<p>In either case, the default schema can be modified by inserting additional migrations between
the migrations distributed with this crate. The new migrations will then automatically be
replayed as necessary when initializing a <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a>. New custom migrations can be
added with each software update, to keep the custom data up to date as the default schema
changes.</p>
<p>Custom migrations can be inserted using <a href="../storage/sql/struct.Config.html#method.migrations" title="method hotshot_query_service::data_source::storage::sql::Config::migrations"><code>Config::migrations</code></a>. Each custom migration will be
inserted into the overall sequence of migrations in order of version number. The migrations
provided by this crate only use version numbers which are multiples of 100, so the non-multiples
can be used to insert custom migrations between the default migrations. You can also replace a
default migration completely by providing a custom migration with the same version number. This
may be useful when an earlier custom migration has altered the schema in such a way that a later
migration no longer works as-is. However, this technique is error prone and should be used only
when necessary.</p>
<p>When using custom migrations, it is the user’s responsibility to ensure that the resulting
schema is compatible with the schema expected by <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a>. Adding things (tables,
columns, indices) should usually be safe. Removing, altering, or renaming things should be done
with extreme caution.</p>
<p>It is standard to store custom migrations as SQL files in a sub-directory of the crate. For ease
of release and deployment, such directories can be embedded into a Rust binary and parsed into
a list of <a href="struct.Migration.html" title="struct hotshot_query_service::data_source::sql::Migration"><code>Migration</code></a> objects using the <a href="../../macro.include_migrations.html" title="macro hotshot_query_service::include_migrations"><code>include_migrations</code></a> macro.</p>
<p>It is also possible to take complete control over migrating the schema using
<a href="../storage/sql/struct.Config.html#method.no_migrations" title="method hotshot_query_service::data_source::storage::sql::Config::no_migrations"><code>Config::no_migrations</code></a> to prevent the <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> from running its own migrations. The
database administrator then becomes responsible for manually migrating the database, ensuring the
schema is up to date, and ensuring that the schema is at all times compatible with the schema
expected by the current version of this software. Nevertheless, this may be the best option when
your application-specific schema has diverged significantly from the default schema.</p>
<h2 id="synchronization"><a class="doc-anchor" href="#synchronization">§</a>Synchronization</h2>
<p><a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> implements <a href="../trait.VersionedDataSource.html" title="trait hotshot_query_service::data_source::VersionedDataSource"><code>VersionedDataSource</code></a>, which means
changes are applied to the underlying database via transactions. <a href="../storage/sql/struct.Transaction.html" title="struct hotshot_query_service::data_source::storage::sql::Transaction"><code>Transaction</code></a> maps exactly to
a transaction in the underling RDBMS, and inherits the underlying concurrency semantics.</p>
<h2 id="extension-and-composition"><a class="doc-anchor" href="#extension-and-composition">§</a>Extension and Composition</h2>
<p><a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> is designed to be both extensible (so you can add additional state to the API
modules defined in this crate) and composable (so you can use <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> as one component
of a larger state type for an application with additional modules).</p>
<h3 id="extension"><a class="doc-anchor" href="#extension">§</a>Extension</h3>
<p>It is possible to add additional, application-specific state to <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a>. If the new
state should live in memory, simply wrap the <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> in an
<a href="../struct.ExtensibleDataSource.html" title="struct hotshot_query_service::data_source::ExtensibleDataSource"><code>ExtensibleDataSource</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">type </span>AppState = <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str;

<span class="kw">let </span>data_source: ExtensibleDataSource&lt;SqlDataSource&lt;AppTypes, NoFetching&gt;, AppState&gt; =
    ExtensibleDataSource::new(config.connect(NoFetching).<span class="kw">await</span><span class="question-mark">?</span>, <span class="string">"app state"</span>);</code></pre></div>
<p>The <a href="../struct.ExtensibleDataSource.html" title="struct hotshot_query_service::data_source::ExtensibleDataSource"><code>ExtensibleDataSource</code></a> wrapper implements all the same data
source traits as <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a>, and also provides access to the <code>AppState</code> parameter for use
in API endpoint handlers. This can be used to implement an app-specific data source trait and
add a new API endpoint that uses this app-specific data, as described in the
<a href="../../index.html#extension" title="mod hotshot_query_service">extension guide</a>.</p>
<p>If the new application-specific state should live in the SQL database itself, the implementation
is more involved, but still possible. Follow the steps for <a href="#custom-migrations">custom
migrations</a> to modify the database schema to account for the new data you
want to store. You can then access this data through the <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> using
<a href="../trait.VersionedDataSource.html#tymethod.read" title="method hotshot_query_service::data_source::VersionedDataSource::read"><code>read</code></a> to run a custom read-only SQL query or
<a href="../trait.VersionedDataSource.html#tymethod.write" title="method hotshot_query_service::data_source::VersionedDataSource::write"><code>write</code></a> to execute a custom atomic mutation of the
database.</p>
<h3 id="composition"><a class="doc-anchor" href="#composition">§</a>Composition</h3>
<p>Composing <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> with other module states is fairly simple – just
create an aggregate struct containing both <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> and your additional module
states, as described in the <a href="../../index.html#composition" title="mod hotshot_query_service">composition guide</a>. If the additional modules
have data that should live in the same database as the <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> data, you can follow
the steps in <a href="#custom-migrations">custom migrations</a> to accommodate this.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>AppState {
    hotshot_qs: SqlDataSource&lt;AppTypes, NoFetching&gt;,
    <span class="comment">// additional state for other modules
</span>}

<span class="kw">async fn </span>init_server&lt;Ver: StaticVersionType + <span class="lifetime">'static</span>&gt;(
    config: Config,
    hotshot: SystemContextHandle&lt;AppTypes, AppNodeImpl, AppVersions&gt;,
) -&gt; anyhow::Result&lt;App&lt;Arc&lt;AppState&gt;, Error&gt;&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>hotshot_qs = config.connect(NoFetching).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="comment">// Initialize storage for other modules, using `hotshot_qs` to access the database.
    </span><span class="kw">let </span>tx = hotshot_qs.write().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="comment">// ...
    </span>tx.commit().<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="kw">let </span>state = Arc::new(AppState {
        hotshot_qs,
        <span class="comment">// additional state for other modules
    </span>});
    <span class="kw">let </span><span class="kw-2">mut </span>app = App::with_state(state.clone());
    <span class="comment">// Register API modules.

    </span>spawn(<span class="kw">async move </span>{
        <span class="kw">let </span><span class="kw-2">mut </span>events = hotshot.event_stream();
        <span class="kw">while let </span><span class="prelude-val">Some</span>(event) = events.next().<span class="kw">await </span>{
            <span class="kw">if </span>state.hotshot_qs.update(<span class="kw-2">&amp;</span>event).<span class="kw">await</span>.is_err() {
                <span class="kw">continue</span>;
            }

            <span class="kw">let </span><span class="kw-2">mut </span>tx = state.hotshot_qs.write().<span class="kw">await</span>.unwrap();
            <span class="comment">// Update other modules' states based on `event`, using `tx` to access the database.
            </span>tx.commit().<span class="kw">await</span>.unwrap();
        }
    });

    <span class="prelude-val">Ok</span>(app)
}</code></pre></div>
</div></details><h2 id="aliased-type" class="section-header">Aliased Type<a href="#aliased-type" class="anchor">§</a></h2><pre class="rust item-decl"><code>struct SqlDataSource&lt;Types, P&gt; {
    fetcher: <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;<a class="struct" href="../fetching/struct.Fetcher.html" title="struct hotshot_query_service::data_source::fetching::Fetcher">Fetcher</a>&lt;Types, <a class="struct" href="../storage/sql/struct.SqlStorage.html" title="struct hotshot_query_service::data_source::storage::sql::SqlStorage">SqlStorage</a>, P&gt;&gt;,
    scanner: <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../task/struct.BackgroundTask.html" title="struct hotshot_query_service::task::BackgroundTask">BackgroundTask</a>&gt;,
    aggregator: <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../task/struct.BackgroundTask.html" title="struct hotshot_query_service::task::BackgroundTask">BackgroundTask</a>&gt;,
    pruner: <a class="struct" href="../fetching/struct.Pruner.html" title="struct hotshot_query_service::data_source::fetching::Pruner">Pruner</a>&lt;Types, <a class="struct" href="../storage/sql/struct.SqlStorage.html" title="struct hotshot_query_service::data_source::storage::sql::SqlStorage">SqlStorage</a>&gt;,
}</code></pre><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.fetcher" class="structfield section-header"><a href="#structfield.fetcher" class="anchor field">§</a><code>fetcher: <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;<a class="struct" href="../fetching/struct.Fetcher.html" title="struct hotshot_query_service::data_source::fetching::Fetcher">Fetcher</a>&lt;Types, <a class="struct" href="../storage/sql/struct.SqlStorage.html" title="struct hotshot_query_service::data_source::storage::sql::SqlStorage">SqlStorage</a>, P&gt;&gt;</code></span><span id="structfield.scanner" class="structfield section-header"><a href="#structfield.scanner" class="anchor field">§</a><code>scanner: <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../task/struct.BackgroundTask.html" title="struct hotshot_query_service::task::BackgroundTask">BackgroundTask</a>&gt;</code></span><span id="structfield.aggregator" class="structfield section-header"><a href="#structfield.aggregator" class="anchor field">§</a><code>aggregator: <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../task/struct.BackgroundTask.html" title="struct hotshot_query_service::task::BackgroundTask">BackgroundTask</a>&gt;</code></span><span id="structfield.pruner" class="structfield section-header"><a href="#structfield.pruner" class="anchor field">§</a><code>pruner: <a class="struct" href="../fetching/struct.Pruner.html" title="struct hotshot_query_service::data_source::fetching::Pruner">Pruner</a>&lt;Types, <a class="struct" href="../storage/sql/struct.SqlStorage.html" title="struct hotshot_query_service::data_source::storage::sql::SqlStorage">SqlStorage</a>&gt;</code></span><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-FetchingDataSource%3CTypes,+SqlStorage,+P%3E" class="impl"><a class="src rightside" href="../../../src/hotshot_query_service/data_source/sql.rs.html#301-316">Source</a><a href="#impl-FetchingDataSource%3CTypes,+SqlStorage,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Types, P: <a class="trait" href="../fetching/trait.AvailabilityProvider.html" title="trait hotshot_query_service::data_source::fetching::AvailabilityProvider">AvailabilityProvider</a>&lt;Types&gt;&gt; <a class="type" href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource">SqlDataSource</a>&lt;Types, P&gt;<div class="where">where
    Types: <a class="trait" href="../../../hotshot_types/traits/node_implementation/trait.NodeType.html" title="trait hotshot_types::traits::node_implementation::NodeType">NodeType</a>,
    <a class="type" href="../../type.Header.html" title="type hotshot_query_service::Header">Header</a>&lt;Types&gt;: <a class="trait" href="../../availability/trait.QueryableHeader.html" title="trait hotshot_query_service::availability::QueryableHeader">QueryableHeader</a>&lt;Types&gt;,
    <a class="type" href="../../type.Payload.html" title="type hotshot_query_service::Payload">Payload</a>&lt;Types&gt;: <a class="trait" href="../../availability/trait.QueryablePayload.html" title="trait hotshot_query_service::availability::QueryablePayload">QueryablePayload</a>&lt;Types&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.connect" class="method"><a class="src rightside" href="../../../src/hotshot_query_service/data_source/sql.rs.html#313-315">Source</a><h4 class="code-header">pub async fn <a href="#method.connect" class="fn">connect</a>(
    config: <a class="type" href="type.Config.html" title="type hotshot_query_service::data_source::sql::Config">Config</a>,
    provider: P,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="type.Builder.html" title="type hotshot_query_service::data_source::sql::Builder">Builder</a>&lt;Types, P&gt;, <a class="struct" href="struct.Error.html" title="struct hotshot_query_service::data_source::sql::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Connect to a remote database.</p>
<p>This function returns a <a href="../fetching/struct.Builder.html" title="struct hotshot_query_service::data_source::fetching::Builder"><code>fetching::Builder</code></a> which can be used to set options on the
underlying <a href="../fetching/struct.FetchingDataSource.html" title="struct hotshot_query_service::data_source::fetching::FetchingDataSource"><code>FetchingDataSource</code></a>, before constructing the <a href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource"><code>SqlDataSource</code></a> with
<a href="../fetching/struct.Builder.html#method.build" title="method hotshot_query_service::data_source::fetching::Builder::build"><code>build</code></a>. For a convenient constructor that uses the default
fetching options, see <a href="../storage/sql/struct.Config.html#method.connect" title="method hotshot_query_service::data_source::storage::sql::Config::connect"><code>Config::connect</code></a>.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-DataSourceLifeCycle-for-FetchingDataSource%3CMockTypes,+SqlStorage,+P%3E" class="impl"><a class="src rightside" href="../../../src/hotshot_query_service/data_source/sql.rs.html#332-368">Source</a><a href="#impl-DataSourceLifeCycle-for-FetchingDataSource%3CMockTypes,+SqlStorage,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P: <a class="trait" href="../fetching/trait.AvailabilityProvider.html" title="trait hotshot_query_service::data_source::fetching::AvailabilityProvider">AvailabilityProvider</a>&lt;<a class="struct" href="../../testing/mocks/struct.MockTypes.html" title="struct hotshot_query_service::testing::mocks::MockTypes">MockTypes</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a>&gt; <a class="trait" href="../../testing/consensus/trait.DataSourceLifeCycle.html" title="trait hotshot_query_service::testing::consensus::DataSourceLifeCycle">DataSourceLifeCycle</a> for <a class="type" href="type.SqlDataSource.html" title="type hotshot_query_service::data_source::sql::SqlDataSource">SqlDataSource</a>&lt;<a class="struct" href="../../testing/mocks/struct.MockTypes.html" title="struct hotshot_query_service::testing::mocks::MockTypes">MockTypes</a>, P&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Storage" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/hotshot_query_service/data_source/sql.rs.html#335">Source</a><a href="#associatedtype.Storage" class="anchor">§</a><h4 class="code-header">type <a href="../../testing/consensus/trait.DataSourceLifeCycle.html#associatedtype.Storage" class="associatedtype">Storage</a> = <a class="struct" href="../storage/sql/testing/struct.TmpDb.html" title="struct hotshot_query_service::data_source::storage::sql::testing::TmpDb">TmpDb</a></h4></section></summary><div class='docblock'>Backing storage for the data source. <a href="../../testing/consensus/trait.DataSourceLifeCycle.html#associatedtype.Storage">Read more</a></div></details><section id="method.create" class="method trait-impl"><a class="src rightside" href="../../../src/hotshot_query_service/data_source/sql.rs.html#337-339">Source</a><a href="#method.create" class="anchor">§</a><h4 class="code-header">fn <a href="../../testing/consensus/trait.DataSourceLifeCycle.html#tymethod.create" class="fn">create</a>&lt;'async_trait&gt;(
    _node_id: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/core/pin/struct.Pin.html" title="struct core::pin::Pin">Pin</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = Self::<a class="associatedtype" href="../../testing/consensus/trait.DataSourceLifeCycle.html#associatedtype.Storage" title="type hotshot_query_service::testing::consensus::DataSourceLifeCycle::Storage">Storage</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + 'async_trait&gt;&gt;<div class="where">where
    Self: 'async_trait,</div></h4></section><section id="method.connect-1" class="method trait-impl"><a class="src rightside" href="../../../src/hotshot_query_service/data_source/sql.rs.html#341-343">Source</a><a href="#method.connect-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../testing/consensus/trait.DataSourceLifeCycle.html#tymethod.connect" class="fn">connect</a>&lt;'life0, 'async_trait&gt;(
    tmp_db: &amp;'life0 Self::<a class="associatedtype" href="../../testing/consensus/trait.DataSourceLifeCycle.html#associatedtype.Storage" title="type hotshot_query_service::testing::consensus::DataSourceLifeCycle::Storage">Storage</a>,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/core/pin/struct.Pin.html" title="struct core::pin::Pin">Pin</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = Self&gt; + <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + 'async_trait&gt;&gt;<div class="where">where
    Self: 'async_trait,
    'life0: 'async_trait,</div></h4></section><section id="method.reset" class="method trait-impl"><a class="src rightside" href="../../../src/hotshot_query_service/data_source/sql.rs.html#345-352">Source</a><a href="#method.reset" class="anchor">§</a><h4 class="code-header">fn <a href="../../testing/consensus/trait.DataSourceLifeCycle.html#tymethod.reset" class="fn">reset</a>&lt;'life0, 'async_trait&gt;(
    tmp_db: &amp;'life0 Self::<a class="associatedtype" href="../../testing/consensus/trait.DataSourceLifeCycle.html#associatedtype.Storage" title="type hotshot_query_service::testing::consensus::DataSourceLifeCycle::Storage">Storage</a>,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/core/pin/struct.Pin.html" title="struct core::pin::Pin">Pin</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = Self&gt; + <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + 'async_trait&gt;&gt;<div class="where">where
    Self: 'async_trait,
    'life0: 'async_trait,</div></h4></section><section id="method.leaf_only_ds" class="method trait-impl"><a class="src rightside" href="../../../src/hotshot_query_service/data_source/sql.rs.html#354-363">Source</a><a href="#method.leaf_only_ds" class="anchor">§</a><h4 class="code-header">fn <a href="../../testing/consensus/trait.DataSourceLifeCycle.html#method.leaf_only_ds" class="fn">leaf_only_ds</a>&lt;'life0, 'async_trait&gt;(
    tmp_db: &amp;'life0 Self::<a class="associatedtype" href="../../testing/consensus/trait.DataSourceLifeCycle.html#associatedtype.Storage" title="type hotshot_query_service::testing::consensus::DataSourceLifeCycle::Storage">Storage</a>,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/core/pin/struct.Pin.html" title="struct core::pin::Pin">Pin</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = Self&gt; + <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + 'async_trait&gt;&gt;<div class="where">where
    Self: 'async_trait,
    'life0: 'async_trait,</div></h4></section><section id="method.handle_event" class="method trait-impl"><a class="src rightside" href="../../../src/hotshot_query_service/data_source/sql.rs.html#365-367">Source</a><a href="#method.handle_event" class="anchor">§</a><h4 class="code-header">fn <a href="../../testing/consensus/trait.DataSourceLifeCycle.html#tymethod.handle_event" class="fn">handle_event</a>&lt;'life0, 'life1, 'async_trait&gt;(
    &amp;'life0 self,
    event: &amp;'life1 <a class="struct" href="../../../hotshot_types/event/struct.Event.html" title="struct hotshot_types::event::Event">Event</a>&lt;<a class="struct" href="../../testing/mocks/struct.MockTypes.html" title="struct hotshot_query_service::testing::mocks::MockTypes">MockTypes</a>&gt;,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/core/pin/struct.Pin.html" title="struct core::pin::Pin">Pin</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.unit.html">()</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + 'async_trait&gt;&gt;<div class="where">where
    Self: 'async_trait,
    'life0: 'async_trait,
    'life1: 'async_trait,</div></h4></section><details class="toggle method-toggle" open><summary><section id="method.setup" class="method trait-impl"><a class="src rightside" href="../../../src/hotshot_query_service/testing/consensus.rs.html#333">Source</a><a href="#method.setup" class="anchor">§</a><h4 class="code-header">fn <a href="../../testing/consensus/trait.DataSourceLifeCycle.html#method.setup" class="fn">setup</a>&lt;'life0, 'async_trait&gt;(
    _network: &amp;'life0 mut <a class="struct" href="../../testing/consensus/struct.MockNetwork.html" title="struct hotshot_query_service::testing::consensus::MockNetwork">MockNetwork</a>&lt;Self&gt;,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/core/pin/struct.Pin.html" title="struct core::pin::Pin">Pin</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.unit.html">()</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + 'async_trait&gt;&gt;<div class="where">where
    Self: 'async_trait,
    'life0: 'async_trait,</div></h4></section></summary><div class='docblock'>Setup runs after setting up the network but before starting a test.</div></details></div></details></div><script src="../../../type.impl/hotshot_query_service/data_source/fetching/struct.FetchingDataSource.js" data-self-path="hotshot_query_service::data_source::sql::SqlDataSource" async></script></section></div></main></body></html>