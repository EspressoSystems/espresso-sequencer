#!/usr/bin/env bash
set -euo pipefail

# If we aren't in a nix shell (where this handled in flake.nix) add the target
# directory to the path so that the binaries are found by process-compose.
if [ -z "${IN_NIX_SHELL-}" ]; then
    echo "ALERT: The expected profile for demo-native binaries has been updated"
    echo "from release to test profile. You can still use release binaries by"
    echo -e "manually setting your PATH.\n"
    REPO_ROOT="$(dirname "$(dirname "$(readlink -fm "$0")")")"
    # Default to CARGO_TARGET_DIR if set, otherwise use the default target directory.
    TARGET_DIR="${CARGO_TARGET_DIR:-${REPO_ROOT}/target}"
    echo -e "Appending ${TARGET_DIR}/debug to PATH.\n"
    export "PATH=${TARGET_DIR}/debug:$PATH"
fi

ESPRESSO_BASE_STORAGE_PATH=$(mktemp -d -t espresso-XXXXXXXX)
export ESPRESSO_BASE_STORAGE_PATH
echo "Using sequencer storage path: $ESPRESSO_BASE_STORAGE_PATH"

# If keeping the storage path, to keep it around, run with env CI=true
trap "exit" INT TERM
trap cleanup EXIT
cleanup(){
    # Don't run cleanup if running in the CI. We may be running process-compose
    # with --detach and the cleanup will remove the storage path while the
    # services are still running.
    if [ "$CI" = "true" ]; then
        echo "Running in CI, not cleaning up $ESPRESSO_BASE_STORAGE_PATH"
    else
        echo "Cleaning up sequencer storage path: $ESPRESSO_BASE_STORAGE_PATH"
        rm -rv "$ESPRESSO_BASE_STORAGE_PATH"
    fi
}

# Print the status of the processes of all unhealthy processes every 5 seconds for CI
(
    while true; do
        curl localhost:8080/processes 2>/dev/null | \
            jq '.data[] | {name: .name, status: .status, healthy: .is_ready}' 2>/dev/null || true
        docker ps --filter name=demo-l1-network --format '{{.Status}}' | grep 'healthy' || true
        sleep 1
    done
) &
CURL_PID=$!

# Kill the unhealthy process checker when Ctrl+C is pressed
trap "kill $CURL_PID; exit" SIGINT

# Kill the unhealthy process checker when the script exits
trap "kill $CURL_PID" EXIT

process-compose "$@"
